import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { AudioFeatures } from '@/types/mood';
import { getSpotifyClient } from '@/lib/spotify';

interface GenerateRequest {
  features: AudioFeatures;
  aiSuggestions?: {
    moodDescription: string;
    recommendedGenres: string[];
    contextualNotes: string;
  };
}

export async function POST(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    // Get a fresh Spotify client with valid token
    const spotify = await getSpotifyClient(session);
    if (!spotify) {
      return NextResponse.json(
        { error: 'Failed to initialize Spotify client' },
        { status: 500 }
      );
    }

    const { features, aiSuggestions } = (await req.json()) as GenerateRequest;

    // Get user's top tracks
    const topTracksResponse = await spotify.get(
      '/v1/me/top/tracks?limit=5&time_range=medium_term'
    );

    if (!topTracksResponse.ok) {
      console.error('Top tracks error:', await topTracksResponse.text());
      throw new Error('Failed to fetch top tracks');
    }

    const topTracks = await topTracksResponse.json();
    if (!topTracks.items?.length) {
      return NextResponse.json(
        { error: 'No top tracks found' },
        { status: 404 }
      );
    }

    const seedTracks = topTracks.items.slice(0, 2).map((track: any) => track.id);

    // Build recommendations query parameters
    const params = new URLSearchParams({
      limit: '20',
      seed_tracks: seedTracks.join(','),
      target_energy: features.energy.toString(),
      target_valence: features.valence.toString(),
      target_danceability: features.danceability.toString(),
      target_acousticness: features.acousticness.toString(),
      target_instrumentalness: features.instrumentalness.toString(),
    });

    if (aiSuggestions?.recommendedGenres?.length) {
      const seedGenres = aiSuggestions.recommendedGenres
        .slice(0, 3)
        .map(genre => genre.toLowerCase())
        .join(',');
      params.append('seed_genres', seedGenres);
    }

    // Get recommendations
    const recommendationsResponse = await spotify.get(
      `/v1/recommendations?${params.toString()}`
    );

    if (!recommendationsResponse.ok) {
      console.error('Recommendations error:', await recommendationsResponse.text());
      throw new Error('Failed to get recommendations');
    }

    const recommendations = await recommendationsResponse.json();
    if (!recommendations.tracks?.length) {
      return NextResponse.json(
        { error: 'No recommendations found' },
        { status: 404 }
      );
    }

    // Create a new playlist
    const date = new Date().toLocaleDateString('en-US', {
      month: 'short',
      day: 'numeric',
    });

    const createPlaylistResponse = await spotify.post(
      `/v1/users/${(session.user as any).id}/playlists`,
      {
        name: `Mood Mix - ${date}`,
        description: `Generated by Mood Mixer: ${aiSuggestions?.moodDescription || 'Custom Mood'}`,
        public: false,
      }
    );

    if (!createPlaylistResponse.ok) {
      console.error('Create playlist error:', await createPlaylistResponse.text());
      throw new Error('Failed to create playlist');
    }

    const playlist = await createPlaylistResponse.json();

    // Add tracks to the playlist
    const trackUris = recommendations.tracks.map((track: any) => track.uri);
    const addTracksResponse = await spotify.post(
      `/v1/playlists/${playlist.id}/tracks`,
      {
        uris: trackUris,
      }
    );

    if (!addTracksResponse.ok) {
      console.error('Add tracks error:', await addTracksResponse.text());
      throw new Error('Failed to add tracks to playlist');
    }

    // Analyze each track's contribution to the mood
    const trackAnalysis = recommendations.tracks.map((track: any) => ({
      id: track.id,
      name: track.name,
      artists: track.artists.map((artist: any) => ({ name: artist.name })),
      album: {
        name: track.album.name,
        images: track.album.images,
      },
      external_urls: track.external_urls,
      moodContribution: `${track.name} was chosen for its ${
        track.energy > 0.6 ? 'high energy' : track.energy < 0.4 ? 'calming energy' : 'balanced energy'
      } and ${
        track.valence > 0.6 ? 'uplifting' : track.valence < 0.4 ? 'introspective' : 'neutral'
      } mood, which aligns with the desired emotional atmosphere.`,
    }));

    return NextResponse.json({
      playlistId: playlist.id,
      playlistUrl: playlist.external_urls.spotify,
      tracks: trackAnalysis,
    });

  } catch (error) {
    console.error('Error generating playlist:', error);
    return NextResponse.json(
      { error: 'Failed to generate playlist' },
      { status: 500 }
    );
  }
}
